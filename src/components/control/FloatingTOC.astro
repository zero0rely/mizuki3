---
import { Icon } from "astro-icon/components";
import { siteConfig } from "../../config";

const tocDepth = siteConfig.toc.depth;
const useJapaneseBadge = siteConfig.toc.useJapaneseBadge;
---

<div class="floating-toc-wrapper" data-depth={tocDepth} data-japanese-badge={useJapaneseBadge}>
    <button id="floating-toc-btn" class="floating-toc-btn btn-card" aria-label="Table of Contents">
        <Icon name="material-symbols:format-list-bulleted-rounded" class="text-2xl" />
    </button>
    <div id="floating-toc-panel" class="floating-toc-panel">
        <div class="floating-toc-panel-content" id="floating-toc-content">
            <!-- TOC items will be generated by JavaScript -->
        </div>
    </div>
</div>

<style>
    .floating-toc-wrapper {
        position: fixed;
        right: 6rem;
        bottom: 14rem;
        z-index: 50;
        pointer-events: auto;
        transform: translateX(5rem);
    }

    .floating-toc-btn {
        width: 3.75rem;
        height: 3.75rem;
        border-radius: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--primary);
    }

    .floating-toc-btn.active {
        background: var(--btn-card-bg-active);
    }

    .floating-toc-panel {
        position: absolute;
        bottom: 4rem;
        right: 0;
        width: 18rem;
        max-height: 60vh;
        background: var(--card-bg);
        border: 1px solid var(--line-color);
        border-radius: 1rem;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        overflow: hidden;
        opacity: 0;
        visibility: hidden;
        transform: translateY(10px) scale(0.95);
        transition: all 0.2s ease;
        pointer-events: none;
    }

    .floating-toc-panel.show {
        opacity: 1;
        visibility: visible;
        transform: translateY(0) scale(1);
        pointer-events: auto;
    }

    .floating-toc-panel-content {
        padding: 0.75rem;
        max-height: 60vh;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .floating-toc-panel-content::-webkit-scrollbar {
        width: 4px;
    }

    .floating-toc-panel-content::-webkit-scrollbar-track {
        background: transparent;
    }

    .floating-toc-panel-content::-webkit-scrollbar-thumb {
        background: var(--line-color);
        border-radius: 2px;
    }

    .floating-toc-wrapper.no-toc {
        display: none;
    }

    /* 移动端隐藏，使用顶栏的MobileTOC */
    @media (max-width: 1024px) {
        .floating-toc-wrapper {
            display: none;
        }
    }

    @media (max-width: 1560px) {
        .floating-toc-wrapper {
            box-shadow: 0 0 0 1px var(--btn-regular-bg), 0 0 1em var(--btn-regular-bg);
            border-radius: 1rem;
        }
    }
</style>

<script>
class FloatingTOC {
    private btn: HTMLElement | null;
    private panel: HTMLElement | null;
    private content: HTMLElement | null;
    private wrapper: HTMLElement | null;
    private isOpen = false;

    constructor() {
        this.btn = document.getElementById('floating-toc-btn');
        this.panel = document.getElementById('floating-toc-panel');
        this.content = document.getElementById('floating-toc-content');
        this.wrapper = document.querySelector('.floating-toc-wrapper');
        
        this.init();
    }

    private init() {
        this.generateTOC();
        this.bindEvents();
    }

    private generateTOC() {
        const headings = document.querySelectorAll('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]');
        
        if (headings.length === 0) {
            this.wrapper?.classList.add('no-toc');
            return;
        }

        this.wrapper?.classList.remove('no-toc');

        const maxLevel = parseInt(this.wrapper?.dataset.depth || '3');
        const useJapaneseBadge = this.wrapper?.dataset.japaneseBadge === 'true';

        const japaneseKatakana = [
            "ア", "イ", "ウ", "エ", "オ", "カ", "キ", "ク", "ケ", "コ",
            "サ", "シ", "ス", "セ", "ソ", "タ", "チ", "ツ", "テ", "ト",
            "ナ", "ニ", "ヌ", "ネ", "ノ", "ハ", "ヒ", "フ", "ヘ", "ホ"
        ];

        let minLevel = 6;
        headings.forEach(h => {
            const level = parseInt(h.tagName[1]);
            if (level < minLevel) minLevel = level;
        });

        let html = '';
        let h1Count = 0;

        headings.forEach(heading => {
            const level = parseInt(heading.tagName[1]);
            if (level >= minLevel + maxLevel) return;

            const indent = (level - minLevel) * 1;
            let badge = '';

            if (level === minLevel) {
                h1Count++;
                const badgeText = useJapaneseBadge && h1Count - 1 < japaneseKatakana.length
                    ? japaneseKatakana[h1Count - 1]
                    : h1Count.toString();
                badge = `<span class="floating-toc-badge">${badgeText}</span>`;
            } else if (level === minLevel + 1) {
                badge = '<span class="floating-toc-dot"></span>';
            } else {
                badge = '<span class="floating-toc-dot-small"></span>';
            }

            const text = (heading.textContent || '').replace(/#+\s*$/, '');
            html += `<a href="#${heading.id}" class="floating-toc-item" style="padding-left: ${0.5 + indent}rem" data-level="${level - minLevel}">${badge}<span class="floating-toc-text">${text}</span></a>`;
        });

        if (this.content) {
            this.content.innerHTML = html;
        }
    }

    private bindEvents() {
        this.btn?.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggle();
        });

        document.addEventListener('click', (e) => {
            if (this.isOpen && !this.wrapper?.contains(e.target as Node)) {
                this.close();
            }
        });

        this.content?.addEventListener('click', (e) => {
            const link = (e.target as HTMLElement).closest('a');
            if (link) {
                e.preventDefault();
                const id = link.getAttribute('href')?.slice(1);
                if (id) {
                    const element = document.getElementById(id);
                    if (element) {
                        const top = element.getBoundingClientRect().top + window.scrollY - 80;
                        window.scrollTo({ top, behavior: 'smooth' });
                        this.close();
                    }
                }
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.isOpen) this.close();
        });

        if ((window as any).swup) {
            (window as any).swup.hooks.on('page:view', () => {
                setTimeout(() => this.reinit(), 200);
            });
        }
    }

    private toggle() {
        this.isOpen ? this.close() : this.open();
    }

    private open() {
        this.isOpen = true;
        this.panel?.classList.add('show');
        this.btn?.classList.add('active');
    }

    private close() {
        this.isOpen = false;
        this.panel?.classList.remove('show');
        this.btn?.classList.remove('active');
    }

    private reinit() {
        this.close();
        this.generateTOC();
    }
}

document.addEventListener('DOMContentLoaded', () => new FloatingTOC());
document.addEventListener('swup:page:view', () => new FloatingTOC());
</script>
